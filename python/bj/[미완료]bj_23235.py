# 문제 링크 : https://www.acmicpc.net/problem/23235
# 간단한 문제 설명 : 
# 해결 방법 설명 :            
# 시간/공간 복잡도 : 

# 정렬 알고리즘의 효율성을 비교할 때, 선택 정렬처럼 느린 알고리즘은 N개의 항목을 정렬하는 데 O(N²) 시간이 걸리고, 병합 정렬과 같은 비교 기반 정렬 알고리즘은 합리적인 가정 하에 O(N log(N)) 이상의 속도를 기대하기 어렵습니다. 반면에, 비교를 사용하지 않는 버킷 정렬은 O(N) 시간에 정렬이 가능합니다. 이는 버킷 정렬이 입력 데이터의 값 범위가 N에 비해 작다는 가정에 의존하기 때문입니다.
# 즉, 정렬 알고리즘의 속도는 정렬 대상 데이터에 대해 어떠한 가정을 할 수 있는지에 달려 있습니다.

# 그런데, 그 속도로 인해 종종 간과되는 정렬 알고리즘이 하나 있습니다. 바로 "세계에서 가장 빠른 정렬 알고리즘"인데, 이 알고리즘은 상수 시간, 즉 O(1)에 정렬을 수행한다고 합니다. 물론, 이 알고리즘은 입력 배열이 이미 빠른 접근이 가능한 메모리에 있으며, 또한 이미 정렬되어 있다는 전제 조건 하에 동작합니다.
# 이 문제에서는 "세계에서 가장 빠른 정렬 알고리즘"을 구현하면 됩니다.

# 입력: 입력 파일에는 여러 개의 테스트 케이스가 포함되어 있습니다. 각 테스트 케이스는 정렬할 배열에 대한 설명으로 시작합니다.
# 각 배열 설명은 0보다 크고 100 이하인 정수 N으로 시작하며, 그 뒤에 N개의 정수가 주어집니다. 이 정수들은 오름차순(비감소 순)으로 정렬되어 있습니다. 정렬할 정수들의 범위는 0부터 100,000 사이입니다.
# 마지막 테스트 케이스 후에는 단일 0이 포함된 줄이 주어집니다.

# 출력: 각 테스트 케이스마다 케이스 번호(1부터 시작)를 출력하고, 이어서 "Sorting... done!"이라는 문구를 출력합니다.

# 예제 입력: 5 21 44 48 48 64
# 6 8 19 22 49 53 62
# 8 5 9 14 17 24 25 27 61
# 4 13 21 28 35
# 5 31 38 44 49 60
# 0

# 예제 출력: Case 1: Sorting... done!
# Case 2: Sorting... done!
# Case 3: Sorting... done!
# Case 4: Sorting... done!
# Case 5: Sorting... done!